package leetcode.数学.用Rand7实现Rand10;

import java.util.Random;

/**
 * leetcode 470
 */
public class Solution {
    private int rand7() {
        Random random = new Random();
        return random.nextInt(7) + 1;
    }

    /**
     * 思想：拒绝采样，如果生成的随机数满足要求，那么就返回该随机数，否则会不断生成，直到生成一个满足要求的随机数为止
     * <p>
     * 我们只需要能够满足等概率的生成 10个不同的数即可，具体的生成方法可以有很多种，
     * 比如我们可以利用两个 Rand7()相乘，我们只取其中等概率的 10个不同的数的组合即可，
     * 当然还有许多其他不同的解法，可以利用各种运算和函数的组合等方式来实现
     * ___1  2  3  4  5  6  7
     * 1  1  2  3  4  5  6  7
     * 2  2  4  6  8  10 12 14
     * 3  ...
     * 4
     * 5
     * 6
     * 7  7  14 21 28  35 42 49
     * <p>
     * 从而可以得到每个数的生成概率，从其中选择10个生成概率相同的即可
     * 因为要尽可能减少生成次数，所以那10个数的概率应该尽可能大
     * 因为rand7()*rand7()的范围为1~49，所以可以只取前40个数，则转化为1~10时，每个数生成的概率为4/49
     * 这40个数怎么取？要保证生成概率是相同的
     * <p>
     * {@一个公式：(rand_x-1)*y+rand_y：可以生成随机的1~x*y间的数}
     *
     * @return <p></p>
     * 期望时间复杂度为O(1)，但是最坏情况为inf，因为会一直被拒绝。
     * {@为什么叫拒绝采样？因为在范围之外的数直接被拒绝了}
     */
    public int rand10() {
        int col, row, idx;
        do {
            col = rand7();
            row = rand7();
            idx = row + (col - 1) * 7;  // 为什么这里转换为row与col间的加法？因为纯粹乘法最后生成1~49的概率是不相等的
            //
        } while (idx > 40);
        return 1 + (idx - 1) % 10;  // idx为1~40，均匀的，但是直接模10之后会有0，而要求的范围是1~10
    }
}
